{"ast":null,"code":"export const socketMiddleware = wsActions => {\n  return store => {\n    let socket = null;\n    let isConnected = false;\n    let reconnectTimer = 0;\n    let url = '';\n    return next => action => {\n      const {\n        dispatch\n      } = store;\n      const {\n        wsConnect,\n        wsDisconnect,\n        wsSendMessage,\n        onOpen,\n        onClose,\n        onError,\n        onMessage,\n        wsConnecting\n      } = wsActions;\n      if (wsConnect.match(action)) {\n        console.log('connect');\n        url = action.payload;\n        socket = new WebSocket(url);\n        isConnected = true;\n        dispatch(wsConnecting());\n      }\n      if (socket) {\n        socket.onopen = () => {\n          dispatch(onOpen());\n        };\n        socket.onerror = err => {\n          console.log('error');\n        };\n        socket.onmessage = event => {\n          const {\n            data\n          } = event;\n          const parsedData = JSON.parse(data);\n          dispatch(onMessage(parsedData));\n        };\n        socket.onclose = event => {\n          if (event.code !== 1000) {\n            console.log('error');\n            dispatch(onError(event.code.toString()));\n          }\n          console.log('close');\n          dispatch(onClose());\n          if (isConnected) {\n            dispatch(wsConnecting());\n            reconnectTimer = window.setTimeout(() => {\n              dispatch(wsConnect(url));\n            }, 3000);\n          }\n        };\n        if (wsSendMessage && wsSendMessage.match(action)) {\n          console.log('send');\n          socket.send(JSON.stringify(action.payload));\n        }\n        if (wsDisconnect.match(action)) {\n          console.log('disconnect');\n          clearTimeout(reconnectTimer);\n          isConnected = false;\n          reconnectTimer = 0;\n          socket.close();\n          dispatch(onClose());\n        }\n      }\n      next(action);\n    };\n  };\n};","map":{"version":3,"names":["socketMiddleware","wsActions","store","socket","isConnected","reconnectTimer","url","next","action","dispatch","wsConnect","wsDisconnect","wsSendMessage","onOpen","onClose","onError","onMessage","wsConnecting","match","console","log","payload","WebSocket","onopen","onerror","err","onmessage","event","data","parsedData","JSON","parse","onclose","code","toString","window","setTimeout","send","stringify","clearTimeout","close"],"sources":["C:/Users/Nailusha/Desktop/yandex-dev/react-stellar-burger/src/services/store/middleware/socket-middleware.ts"],"sourcesContent":["import { ActionCreatorWithoutPayload, ActionCreatorWithPayload } from '@reduxjs/toolkit';\r\nimport { Middleware } from 'redux';\r\nimport { RootState } from '../../../utils/types';\r\n\r\n\r\n\r\nexport type TwsActionTypes = {\r\n    wsConnect: ActionCreatorWithPayload<string>,\r\n    wsDisconnect: ActionCreatorWithoutPayload,\r\n    wsSendMessage?: ActionCreatorWithPayload<any>,\r\n    wsConnecting: ActionCreatorWithoutPayload,\r\n    onOpen: ActionCreatorWithoutPayload,\r\n    onClose: ActionCreatorWithoutPayload,\r\n    onError: ActionCreatorWithPayload<string>,\r\n    onMessage: ActionCreatorWithPayload<any>,\r\n}\r\n\r\nexport const socketMiddleware = (wsActions: TwsActionTypes): Middleware<{}, RootState> => {\r\n    return (store) => {\r\n      let socket: WebSocket | null = null;\r\n      let isConnected = false;\r\n      let reconnectTimer = 0;\r\n      let url = '';\r\n\r\n      return next => action => {\r\n        const { dispatch } = store;\r\n        const { wsConnect, wsDisconnect, wsSendMessage, onOpen, \r\n          onClose, onError, onMessage, wsConnecting } = wsActions;\r\n\r\n        if (wsConnect.match(action)) {\r\n          console.log('connect')\r\n          url = action.payload;\r\n          socket = new WebSocket(url);\r\n          isConnected = true;\r\n          dispatch(wsConnecting());\r\n        }\r\n\r\n        if (socket) {\r\n          socket.onopen = () => {\r\n            dispatch(onOpen());\r\n          };\r\n  \r\n          socket.onerror = err  => {\r\n            console.log('error')\r\n          };\r\n  \r\n          socket.onmessage = event => {\r\n            const { data } = event;\r\n            const parsedData = JSON.parse(data);\r\n            dispatch(onMessage(parsedData));\r\n          };\r\n  \r\n          socket.onclose = event => {\r\n            if (event.code !== 1000) {\r\n              console.log('error')\r\n              dispatch(onError(event.code.toString()));\r\n            }\r\n            console.log('close')\r\n            dispatch(onClose());\r\n\r\n            if (isConnected) {\r\n              dispatch(wsConnecting());\r\n              reconnectTimer = window.setTimeout(() => {\r\n                dispatch(wsConnect(url));\r\n              }, 3000)\r\n            }\r\n\r\n          };\r\n  \r\n          if (wsSendMessage && wsSendMessage.match(action)) {\r\n            console.log('send')\r\n            socket.send(JSON.stringify(action.payload));\r\n          }\r\n\r\n          if (wsDisconnect.match(action)) {\r\n            console.log('disconnect')\r\n            clearTimeout(reconnectTimer)\r\n            isConnected = false;\r\n            reconnectTimer = 0;\r\n            socket.close();\r\n            dispatch(onClose());\r\n          }\r\n        }\r\n  \r\n        next(action);\r\n      };\r\n    };\r\n  };\r\n  "],"mappings":"AAiBA,OAAO,MAAMA,gBAAgB,GAAIC,SAAyB,IAAgC;EACtF,OAAQC,KAAK,IAAK;IAChB,IAAIC,MAAwB,GAAG,IAAI;IACnC,IAAIC,WAAW,GAAG,KAAK;IACvB,IAAIC,cAAc,GAAG,CAAC;IACtB,IAAIC,GAAG,GAAG,EAAE;IAEZ,OAAOC,IAAI,IAAIC,MAAM,IAAI;MACvB,MAAM;QAAEC;MAAS,CAAC,GAAGP,KAAK;MAC1B,MAAM;QAAEQ,SAAS;QAAEC,YAAY;QAAEC,aAAa;QAAEC,MAAM;QACpDC,OAAO;QAAEC,OAAO;QAAEC,SAAS;QAAEC;MAAa,CAAC,GAAGhB,SAAS;MAEzD,IAAIS,SAAS,CAACQ,KAAK,CAACV,MAAM,CAAC,EAAE;QAC3BW,OAAO,CAACC,GAAG,CAAC,SAAS,CAAC;QACtBd,GAAG,GAAGE,MAAM,CAACa,OAAO;QACpBlB,MAAM,GAAG,IAAImB,SAAS,CAAChB,GAAG,CAAC;QAC3BF,WAAW,GAAG,IAAI;QAClBK,QAAQ,CAACQ,YAAY,EAAE,CAAC;MAC1B;MAEA,IAAId,MAAM,EAAE;QACVA,MAAM,CAACoB,MAAM,GAAG,MAAM;UACpBd,QAAQ,CAACI,MAAM,EAAE,CAAC;QACpB,CAAC;QAEDV,MAAM,CAACqB,OAAO,GAAGC,GAAG,IAAK;UACvBN,OAAO,CAACC,GAAG,CAAC,OAAO,CAAC;QACtB,CAAC;QAEDjB,MAAM,CAACuB,SAAS,GAAGC,KAAK,IAAI;UAC1B,MAAM;YAAEC;UAAK,CAAC,GAAGD,KAAK;UACtB,MAAME,UAAU,GAAGC,IAAI,CAACC,KAAK,CAACH,IAAI,CAAC;UACnCnB,QAAQ,CAACO,SAAS,CAACa,UAAU,CAAC,CAAC;QACjC,CAAC;QAED1B,MAAM,CAAC6B,OAAO,GAAGL,KAAK,IAAI;UACxB,IAAIA,KAAK,CAACM,IAAI,KAAK,IAAI,EAAE;YACvBd,OAAO,CAACC,GAAG,CAAC,OAAO,CAAC;YACpBX,QAAQ,CAACM,OAAO,CAACY,KAAK,CAACM,IAAI,CAACC,QAAQ,EAAE,CAAC,CAAC;UAC1C;UACAf,OAAO,CAACC,GAAG,CAAC,OAAO,CAAC;UACpBX,QAAQ,CAACK,OAAO,EAAE,CAAC;UAEnB,IAAIV,WAAW,EAAE;YACfK,QAAQ,CAACQ,YAAY,EAAE,CAAC;YACxBZ,cAAc,GAAG8B,MAAM,CAACC,UAAU,CAAC,MAAM;cACvC3B,QAAQ,CAACC,SAAS,CAACJ,GAAG,CAAC,CAAC;YAC1B,CAAC,EAAE,IAAI,CAAC;UACV;QAEF,CAAC;QAED,IAAIM,aAAa,IAAIA,aAAa,CAACM,KAAK,CAACV,MAAM,CAAC,EAAE;UAChDW,OAAO,CAACC,GAAG,CAAC,MAAM,CAAC;UACnBjB,MAAM,CAACkC,IAAI,CAACP,IAAI,CAACQ,SAAS,CAAC9B,MAAM,CAACa,OAAO,CAAC,CAAC;QAC7C;QAEA,IAAIV,YAAY,CAACO,KAAK,CAACV,MAAM,CAAC,EAAE;UAC9BW,OAAO,CAACC,GAAG,CAAC,YAAY,CAAC;UACzBmB,YAAY,CAAClC,cAAc,CAAC;UAC5BD,WAAW,GAAG,KAAK;UACnBC,cAAc,GAAG,CAAC;UAClBF,MAAM,CAACqC,KAAK,EAAE;UACd/B,QAAQ,CAACK,OAAO,EAAE,CAAC;QACrB;MACF;MAEAP,IAAI,CAACC,MAAM,CAAC;IACd,CAAC;EACH,CAAC;AACH,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}